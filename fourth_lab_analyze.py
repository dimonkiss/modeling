import math
import numpy as np
from scipy.special import factorial


class AnalyticalMM4Model:
    """
    ÐÐ½Ð°Ð»Ñ–Ñ‚Ð¸Ñ‡Ð½Ð° Ð¼Ð¾Ð´ÐµÐ»ÑŒ ÑÐ¸ÑÑ‚ÐµÐ¼Ð¸ M/M/4 Ð· Ð½ÐµÐ¾Ð±Ð¼ÐµÐ¶ÐµÐ½Ð¾ÑŽ Ñ‡ÐµÑ€Ð³Ð¾ÑŽ
    """

    def __init__(self, X, mu):
        """
        Ð†Ð½Ñ–Ñ†Ñ–Ð°Ð»Ñ–Ð·Ð°Ñ†Ñ–Ñ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ–Ð² Ð¼Ð¾Ð´ÐµÐ»Ñ–

        Args:
            X: Ð¡ÐµÑ€ÐµÐ´Ð½Ñ–Ð¹ Ñ–Ð½Ñ‚ÐµÑ€Ð²Ð°Ð» Ð¼Ñ–Ð¶ Ð½Ð°Ð´Ñ…Ð¾Ð´Ð¶ÐµÐ½Ð½ÑÐ¼ Ð¿Ð°Ñ€Ñ‚Ñ–Ð¹ (Ñ…Ð²)
            mu: Ð†Ð½Ñ‚ÐµÐ½ÑÐ¸Ð²Ð½Ñ–ÑÑ‚ÑŒ Ð¾Ð±ÑÐ»ÑƒÐ³Ð¾Ð²ÑƒÐ²Ð°Ð½Ð½Ñ Ð¾Ð´Ð½Ñ–Ñ”Ñ— Ð´Ñ–Ð»ÑŒÐ½Ð¸Ñ†Ñ– (Ð¿Ð°Ñ€Ñ‚Ñ–Ð¹/Ñ…Ð²)
        """
        self.X = X
        self.mu = mu
        self.lambd = 1.0 / X  # Ð†Ð½Ñ‚ÐµÐ½ÑÐ¸Ð²Ð½Ñ–ÑÑ‚ÑŒ Ð½Ð°Ð´Ñ…Ð¾Ð´Ð¶ÐµÐ½Ð½Ñ
        self.n = 4  # ÐšÑ–Ð»ÑŒÐºÑ–ÑÑ‚ÑŒ Ð´Ñ–Ð»ÑŒÐ½Ð¸Ñ†ÑŒ

    def calculate_metrics(self):
        """Ð Ð¾Ð·Ñ€Ð°Ñ…ÑƒÐ½Ð¾Ðº Ð¾ÑÐ½Ð¾Ð²Ð½Ð¸Ñ… Ð¿Ð¾ÐºÐ°Ð·Ð½Ð¸ÐºÑ–Ð² ÐµÑ„ÐµÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚Ñ– ÑÐ¸ÑÑ‚ÐµÐ¼Ð¸"""

        # ÐšÐ¾ÐµÑ„Ñ–Ñ†Ñ–Ñ”Ð½Ñ‚ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð½Ñ
        rho = self.lambd / (self.n * self.mu)

        # ÐŸÐµÑ€ÐµÐ²Ñ–Ñ€ÐºÐ° ÑƒÐ¼Ð¾Ð²Ð¸ ÑÑ‚Ð°Ñ†Ñ–Ð¾Ð½Ð°Ñ€Ð½Ð¾ÑÑ‚Ñ–
        if rho >= 1:
            print("âš ï¸  Ð£Ð’ÐÐ“Ð: Ð¡Ð¸ÑÑ‚ÐµÐ¼Ð° Ð½ÐµÑÑ‚Ð°Ð±Ñ–Ð»ÑŒÐ½Ð° (Ï â‰¥ 1)")
            return None

        # Ð™Ð¼Ð¾Ð²Ñ–Ñ€Ð½Ñ–ÑÑ‚ÑŒ Ñ‚Ð¾Ð³Ð¾, Ñ‰Ð¾ ÑÐ¸ÑÑ‚ÐµÐ¼Ð° Ð¿Ð¾Ñ€Ð¾Ð¶Ð½Ñ (P0)
        sum_part = 0
        for k in range(self.n):
            sum_part += (self.lambd / self.mu) ** k / factorial(k)

        p0 = 1.0 / (sum_part + ((self.lambd / self.mu) ** self.n /
                                (factorial(self.n) * (1 - rho))))

        # Ð™Ð¼Ð¾Ð²Ñ–Ñ€Ð½Ñ–ÑÑ‚ÑŒ Ñ‚Ð¾Ð³Ð¾, Ñ‰Ð¾ Ð²ÑÑ– Ð´Ñ–Ð»ÑŒÐ½Ð¸Ñ†Ñ– Ð·Ð°Ð¹Ð½ÑÑ‚Ñ–
        p_all_busy = ((self.lambd / self.mu) ** self.n /
                      (factorial(self.n) * (1 - rho))) * p0

        # Ð¡ÐµÑ€ÐµÐ´Ð½Ñ ÐºÑ–Ð»ÑŒÐºÑ–ÑÑ‚ÑŒ Ð¿Ð°Ñ€Ñ‚Ñ–Ð¹ Ñƒ Ñ‡ÐµÑ€Ð·Ñ–
        Lq = p_all_busy * rho / (1 - rho)

        # Ð¡ÐµÑ€ÐµÐ´Ð½Ñ ÐºÑ–Ð»ÑŒÐºÑ–ÑÑ‚ÑŒ Ð¿Ð°Ñ€Ñ‚Ñ–Ð¹ Ñƒ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ–
        Ls = Lq + (self.lambd / self.mu)

        # Ð¡ÐµÑ€ÐµÐ´Ð½Ñ–Ð¹ Ñ‡Ð°Ñ Ð¾Ñ‡Ñ–ÐºÑƒÐ²Ð°Ð½Ð½Ñ Ð² Ñ‡ÐµÑ€Ð·Ñ–
        Wq = Lq / self.lambd

        # Ð¡ÐµÑ€ÐµÐ´Ð½Ñ–Ð¹ Ñ‡Ð°Ñ Ð¿ÐµÑ€ÐµÐ±ÑƒÐ²Ð°Ð½Ð½Ñ Ð² ÑÐ¸ÑÑ‚ÐµÐ¼Ñ–
        Ws = Wq + (1.0 / self.mu)

        # Ð Ð¾Ð·Ð¿Ð¾Ð´Ñ–Ð» Ð¹Ð¼Ð¾Ð²Ñ–Ñ€Ð½Ð¾ÑÑ‚ÐµÐ¹ ÑÑ‚Ð°Ð½Ñ–Ð²
        states_prob = self.calculate_state_probabilities(p0)

        return {
            'rho': rho,
            'p0': p0,
            'p_all_busy': p_all_busy,
            'Lq': Lq,  # Ð¡ÐµÑ€ÐµÐ´Ð½Ñ Ð´Ð¾Ð²Ð¶Ð¸Ð½Ð° Ñ‡ÐµÑ€Ð³Ð¸
            'Ls': Ls,  # Ð¡ÐµÑ€ÐµÐ´Ð½Ñ ÐºÑ–Ð»ÑŒÐºÑ–ÑÑ‚ÑŒ Ñƒ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ–
            'Wq': Wq,  # Ð¡ÐµÑ€ÐµÐ´Ð½Ñ–Ð¹ Ñ‡Ð°Ñ Ð² Ñ‡ÐµÑ€Ð·Ñ–
            'Ws': Ws,  # Ð¡ÐµÑ€ÐµÐ´Ð½Ñ–Ð¹ Ñ‡Ð°Ñ Ð² ÑÐ¸ÑÑ‚ÐµÐ¼Ñ–
            'states_prob': states_prob
        }

    def calculate_state_probabilities(self, p0):
        """Ð Ð¾Ð·Ñ€Ð°Ñ…ÑƒÐ½Ð¾Ðº Ð¹Ð¼Ð¾Ð²Ñ–Ñ€Ð½Ð¾ÑÑ‚ÐµÐ¹ ÐºÐ¾Ð¶Ð½Ð¾Ð³Ð¾ ÑÑ‚Ð°Ð½Ñƒ ÑÐ¸ÑÑ‚ÐµÐ¼Ð¸"""
        states_prob = [p0]  # P0

        for k in range(1, self.n + 1):
            pk = ((self.lambd / self.mu) ** k / factorial(k)) * p0
            states_prob.append(pk)

        # Ð”Ð»Ñ ÑÑ‚Ð°Ð½Ñ–Ð² k > n
        k = self.n + 1
        while True:
            pk = states_prob[self.n] * ((self.lambd / (self.n * self.mu)) ** (k - self.n))
            if pk < 1e-6:  # ÐšÑ€Ð¸Ñ‚ÐµÑ€Ñ–Ð¹ Ð·ÑƒÐ¿Ð¸Ð½ÐºÐ¸
                break
            states_prob.append(pk)
            k += 1

        return states_prob

    def find_max_X_for_queue(self, target_queue=20, mu_estimate=1 / 45):
        """
        ÐŸÐ¾ÑˆÑƒÐº Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ X, Ð¿Ñ€Ð¸ ÑÐºÐ¾Ð¼Ñƒ ÑÐµÑ€ÐµÐ´Ð½Ñ Ñ‡ÐµÑ€Ð³Ð° Ð½Ðµ Ð¿ÐµÑ€ÐµÐ²Ð¸Ñ‰ÑƒÑ” Ð·Ð°Ð´Ð°Ð½Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ

        Args:
            target_queue: ÐœÐ°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð° Ð´Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼Ð° ÑÐµÑ€ÐµÐ´Ð½Ñ Ð´Ð¾Ð²Ð¶Ð¸Ð½Ð° Ñ‡ÐµÑ€Ð³Ð¸
            mu_estimate: ÐžÑ†Ñ–Ð½ÐºÐ° Ñ–Ð½Ñ‚ÐµÐ½ÑÐ¸Ð²Ð½Ð¾ÑÑ‚Ñ– Ð¾Ð±ÑÐ»ÑƒÐ³Ð¾Ð²ÑƒÐ²Ð°Ð½Ð½Ñ
        """
        print("ðŸ” ÐŸÐ¾ÑˆÑƒÐº Ð¾Ð¿Ñ‚Ð¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ X Ð°Ð½Ð°Ð»Ñ–Ñ‚Ð¸Ñ‡Ð½Ð¸Ð¼ Ð¼ÐµÑ‚Ð¾Ð´Ð¾Ð¼...")
        print(f"Ð¦Ñ–Ð»ÑŒ: Lq â‰¤ {target_queue} Ð¿Ð°Ñ€Ñ‚Ñ–Ð¹")

        # ÐœÐµÑ‚Ð¾Ð´ Ð±Ñ–ÑÐµÐºÑ†Ñ–Ñ—
        low = 5.0
        high = 120.0
        tolerance = 0.1

        iteration = 0
        while high - low > tolerance and iteration < 20:
            mid = (low + high) / 2
            self.X = mid
            self.lambd = 1.0 / mid

            results = self.calculate_metrics()

            if results is None:
                # Ð¡Ð¸ÑÑ‚ÐµÐ¼Ð° Ð½ÐµÑÑ‚Ð°Ð±Ñ–Ð»ÑŒÐ½Ð° - Ð·Ð±Ñ–Ð»ÑŒÑˆÑƒÑ”Ð¼Ð¾ X
                low = mid
            else:
                Lq = results['Lq']

                if Lq <= target_queue:
                    high = mid  # ÐœÐ¾Ð¶Ð½Ð° Ð·Ð¼ÐµÐ½ÑˆÐ¸Ñ‚Ð¸ Ñ–Ð½Ñ‚ÐµÑ€Ð²Ð°Ð»
                else:
                    low = mid  # ÐŸÐ¾Ñ‚Ñ€Ñ–Ð±Ð½Ð¾ Ð·Ð±Ñ–Ð»ÑŒÑˆÐ¸Ñ‚Ð¸ Ñ–Ð½Ñ‚ÐµÑ€Ð²Ð°Ð»

            iteration += 1
            print(f"Ð†Ñ‚ÐµÑ€Ð°Ñ†Ñ–Ñ {iteration}: X = {mid:.2f}, Lq = {Lq:.2f}")

        optimal_X = (low + high) / 2
        return optimal_X


def estimate_processing_time():
    """
    ÐžÑ†Ñ–Ð½ÐºÐ° ÑÐµÑ€ÐµÐ´Ð½ÑŒÐ¾Ð³Ð¾ Ñ‡Ð°ÑÑƒ Ð¾Ð±Ñ€Ð¾Ð±ÐºÐ¸ Ð¿Ð°Ñ€Ñ‚Ñ–Ñ— Ð´Ð»Ñ Ñ€Ð¾Ð·Ñ€Ð°Ñ…ÑƒÐ½ÐºÑƒ mu
    """
    print("\nðŸ“Š ÐžÑ†Ñ–Ð½ÐºÐ° Ñ‡Ð°ÑÑƒ Ð¾Ð±Ñ€Ð¾Ð±ÐºÐ¸ Ð¿Ð°Ñ€Ñ‚Ñ–Ñ—:")

    # Ð”ÐµÑ‚ÐµÑ€Ð¼Ñ–Ð½Ð¾Ð²Ð°Ð½Ñ– ÑÐºÐ»Ð°Ð´Ð¾Ð²Ñ–
    pre_processing = 5  # Ñ…Ð² (Ð´Ð»Ñ 2 Ð· 4 Ð´ÐµÑ‚Ð°Ð»ÐµÐ¹)
    assembly = 32  # Ñ…Ð² (4 Ð´ÐµÑ‚Ð°Ð»Ñ– Ð¿Ð¾ 8 Ñ…Ð²)
    regulation = 8  # Ñ…Ð² (ÑÐµÑ€ÐµÐ´Ð½Ñ–Ð¹ Ñ‡Ð°Ñ)

    # Ð™Ð¼Ð¾Ð²Ñ–Ñ€Ð½Ñ–ÑÐ½Ñ– ÑÐºÐ»Ð°Ð´Ð¾Ð²Ñ–
    base_time = pre_processing + assembly + regulation

    # Ð£ÑÐµÑ€ÐµÐ´Ð½ÐµÐ½Ð½Ñ Ð· ÑƒÑ€Ð°Ñ…ÑƒÐ²Ð°Ð½Ð½ÑÐ¼ Ð¹Ð¼Ð¾Ð²Ñ–Ñ€Ð½Ð¾ÑÑ‚ÐµÐ¹
    # P(Ð±Ñ€Ð°Ðº) = 0.01 â†’ Ñ‡Ð°Ñ = 0
    # P(Ð·Ð°Ð¼Ñ–Ð½Ð°) = 0.02 â†’ Ñ‡Ð°Ñ = base_time + 3
    # P(Ð½Ð¾Ñ€Ð¼Ð°) = 0.97 â†’ Ñ‡Ð°Ñ = base_time

    avg_time = (0.01 * 0 + 0.02 * (base_time + 3) + 0.97 * base_time)

    print(f"  ÐŸÐ¾Ð¿ÐµÑ€ÐµÐ´Ð½Ñ Ð¾Ð±Ñ€Ð¾Ð±ÐºÐ°: {pre_processing} Ñ…Ð²")
    print(f"  Ð¡ÐºÐ»Ð°Ð´Ð°Ð½Ð½Ñ: {assembly} Ñ…Ð²")
    print(f"  Ð ÐµÐ³ÑƒÐ»ÑŽÐ²Ð°Ð½Ð½Ñ: {regulation} Ñ…Ð²")
    print(f"  Ð‘Ð°Ð·Ð¾Ð²Ð° Ð¾Ð±Ñ€Ð¾Ð±ÐºÐ°: {base_time} Ñ…Ð²")
    print(f"  Ð£ÑÐµÑ€ÐµÐ´Ð½ÐµÐ½Ð¸Ð¹ Ñ‡Ð°Ñ: {avg_time:.2f} Ñ…Ð²")

    mu = 1.0 / avg_time  # Ð†Ð½Ñ‚ÐµÐ½ÑÐ¸Ð²Ð½Ñ–ÑÑ‚ÑŒ Ð¾Ð±ÑÐ»ÑƒÐ³Ð¾Ð²ÑƒÐ²Ð°Ð½Ð½Ñ
    print(f"  Ð†Ð½Ñ‚ÐµÐ½ÑÐ¸Ð²Ð½Ñ–ÑÑ‚ÑŒ Ð¾Ð±ÑÐ»ÑƒÐ³Ð¾Ð²ÑƒÐ²Ð°Ð½Ð½Ñ Î¼: {mu:.4f} Ð¿Ð°Ñ€Ñ‚Ñ–Ð¹/Ñ…Ð²")

    return mu


def main():
    """ÐžÑÐ½Ð¾Ð²Ð½Ð° Ñ„ÑƒÐ½ÐºÑ†Ñ–Ñ Ð´Ð»Ñ Ð°Ð½Ð°Ð»Ñ–Ñ‚Ð¸Ñ‡Ð½Ð¾Ð³Ð¾ Ð´Ð¾ÑÐ»Ñ–Ð´Ð¶ÐµÐ½Ð½Ñ"""
    print("=" * 60)
    print("ÐÐÐÐ›Ð†Ð¢Ð˜Ð§ÐÐ ÐœÐžÐ”Ð•Ð›Ð¬ Ð¡Ð˜Ð¡Ð¢Ð•ÐœÐ˜ M/M/4")
    print("=" * 60)

    # ÐžÑ†Ñ–Ð½ÐºÐ° Ñ–Ð½Ñ‚ÐµÐ½ÑÐ¸Ð²Ð½Ð¾ÑÑ‚Ñ– Ð¾Ð±ÑÐ»ÑƒÐ³Ð¾Ð²ÑƒÐ²Ð°Ð½Ð½Ñ
    mu = estimate_processing_time()

    # Ð¢ÐµÑÑ‚Ð¾Ð²Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ X
    test_X = 15
    print(f"\nðŸ“ˆ ÐÐ½Ð°Ð»Ñ–Ð· Ð´Ð»Ñ X = {test_X} Ñ…Ð²:")

    model = AnalyticalMM4Model(X=test_X, mu=mu)
    results = model.calculate_metrics()

    if results:
        print(f"  ÐšÐ¾ÐµÑ„Ñ–Ñ†Ñ–Ñ”Ð½Ñ‚ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð½Ñ Ï: {results['rho']:.4f}")
        print(f"  Ð™Ð¼Ð¾Ð²Ñ–Ñ€Ð½Ñ–ÑÑ‚ÑŒ Ð¿Ñ€Ð¾ÑÑ‚Ð¾ÑŽ P0: {results['p0']:.4f}")
        print(f"  Ð™Ð¼Ð¾Ð²Ñ–Ñ€Ð½Ñ–ÑÑ‚ÑŒ Ð·Ð°Ð¹Ð½ÑÑ‚Ð¾ÑÑ‚Ñ– Ð²ÑÑ–Ñ… Ð´Ñ–Ð»ÑŒÐ½Ð¸Ñ†ÑŒ: {results['p_all_busy']:.4f}")
        print(f"  Ð¡ÐµÑ€ÐµÐ´Ð½Ñ Ð´Ð¾Ð²Ð¶Ð¸Ð½Ð° Ñ‡ÐµÑ€Ð³Ð¸ Lq: {results['Lq']:.2f} Ð¿Ð°Ñ€Ñ‚Ñ–Ð¹")
        print(f"  Ð¡ÐµÑ€ÐµÐ´Ð½Ñ ÐºÑ–Ð»ÑŒÐºÑ–ÑÑ‚ÑŒ Ñƒ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ– Ls: {results['Ls']:.2f} Ð¿Ð°Ñ€Ñ‚Ñ–Ð¹")
        print(f"  Ð¡ÐµÑ€ÐµÐ´Ð½Ñ–Ð¹ Ñ‡Ð°Ñ Ð¾Ñ‡Ñ–ÐºÑƒÐ²Ð°Ð½Ð½Ñ Wq: {results['Wq']:.2f} Ñ…Ð²")
        print(f"  Ð¡ÐµÑ€ÐµÐ´Ð½Ñ–Ð¹ Ñ‡Ð°Ñ Ð² ÑÐ¸ÑÑ‚ÐµÐ¼Ñ– Ws: {results['Ws']:.2f} Ñ…Ð²")

    # ÐŸÐ¾ÑˆÑƒÐº Ð¾Ð¿Ñ‚Ð¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ X
    print("\nðŸŽ¯ ÐŸÐ¾ÑˆÑƒÐº Ð¾Ð¿Ñ‚Ð¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ X...")
    optimal_X = model.find_max_X_for_queue(target_queue=20, mu_estimate=mu)

    print(f"\nâœ… Ð Ð•Ð—Ð£Ð›Ð¬Ð¢ÐÐ¢:")
    print(f"ÐžÐ¿Ñ‚Ð¸Ð¼Ð°Ð»ÑŒÐ½Ð¸Ð¹ Ñ–Ð½Ñ‚ÐµÑ€Ð²Ð°Ð» X = {optimal_X:.2f} Ñ…Ð²")
    print(f"Ð†Ð½Ñ‚ÐµÐ½ÑÐ¸Ð²Ð½Ñ–ÑÑ‚ÑŒ Î» = {1 / optimal_X:.4f} Ð¿Ð°Ñ€Ñ‚Ñ–Ð¹/Ñ…Ð²")

    # ÐŸÐµÑ€ÐµÐ²Ñ–Ñ€ÐºÐ° Ð´Ð»Ñ Ð¾Ð¿Ñ‚Ð¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ X
    model_opt = AnalyticalMM4Model(X=optimal_X, mu=mu)
    final_results = model_opt.calculate_metrics()

    if final_results:
        print(f"\nðŸ“Š ÐŸÐ¾ÐºÐ°Ð·Ð½Ð¸ÐºÐ¸ Ð´Ð»Ñ Ð¾Ð¿Ñ‚Ð¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ X:")
        print(f"  Ð¡ÐµÑ€ÐµÐ´Ð½Ñ Ð´Ð¾Ð²Ð¶Ð¸Ð½Ð° Ñ‡ÐµÑ€Ð³Ð¸: {final_results['Lq']:.2f} Ð¿Ð°Ñ€Ñ‚Ñ–Ð¹")
        print(f"  ÐšÐ¾ÐµÑ„Ñ–Ñ†Ñ–Ñ”Ð½Ñ‚ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð½Ñ: {final_results['rho']:.3f}")

        # ÐÐ½Ð°Ð»Ñ–Ð· Ð¹Ð¼Ð¾Ð²Ñ–Ñ€Ð½Ð¾ÑÑ‚ÐµÐ¹ ÑÑ‚Ð°Ð½Ñ–Ð²
        print(f"\nðŸ“‹ Ð™Ð¼Ð¾Ð²Ñ–Ñ€Ð½Ð¾ÑÑ‚Ñ– ÐºÐ»ÑŽÑ‡Ð¾Ð²Ð¸Ñ… ÑÑ‚Ð°Ð½Ñ–Ð²:")
        states = final_results['states_prob']
        for k, pk in enumerate(states[:10]):  # ÐŸÐµÑ€ÑˆÑ– 10 ÑÑ‚Ð°Ð½Ñ–Ð²
            print(f"  P{k} = {pk:.4f}")

        # Ð™Ð¼Ð¾Ð²Ñ–Ñ€Ð½Ñ–ÑÑ‚ÑŒ Ñ‚Ð¾Ð³Ð¾, Ñ‰Ð¾ Ñ‡ÐµÑ€Ð³Ð° Ð¿ÐµÑ€ÐµÐ²Ð¸Ñ‰ÑƒÑ” 20
        p_queue_gt_20 = sum(states[25:])  # 4 Ð¾Ð±ÑÐ»ÑƒÐ³Ð¾Ð²ÑƒÑŽÑ‚ÑŒÑÑ + 21 Ð² Ñ‡ÐµÑ€Ð·Ñ– = ÑÑ‚Ð°Ð½ 25
        print(f"  Ð™Ð¼Ð¾Ð²Ñ–Ñ€Ð½Ñ–ÑÑ‚ÑŒ Ñ‡ÐµÑ€Ð³Ð¸ > 20: {p_queue_gt_20:.6f}")


if __name__ == "__main__":
    main()